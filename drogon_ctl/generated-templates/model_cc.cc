//this file is generated by program(drogon_ctl) automatically,don't modify it!
#include "model_cc.h"
#include <drogon/utils/OStringStream.h>
#include <string>
#include <map>
#include <vector>
#include <set>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include <list>
#include <deque>
#include <queue>
#include "create_model.h"
using namespace drogon_ctl;

using namespace drogon;
std::string model_cc::genText(const DrTemplateData& model_cc_view_data)
{
	drogon::OStringStream model_cc_tmp_stream;
	std::string layoutName{""};
	model_cc_tmp_stream << "/**\n";
	model_cc_tmp_stream << " *\n";
	model_cc_tmp_stream << " *  ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << ".cc\n";
	model_cc_tmp_stream << " *  DO NOT EDIT. This file is generated by drogon_ctl\n";
	model_cc_tmp_stream << " *\n";
	model_cc_tmp_stream << " */\n";
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "#include \"";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << ".h\"\n";
auto &relationships=model_cc_view_data.get<std::vector<Relationship>>("relationships");
auto rdbms=model_cc_view_data.get<std::string>("rdbms");
for(auto &relationship : relationships)
{
    if(relationship.type() == Relationship::Type::HasOne ||
       relationship.type() == Relationship::Type::HasMany ||
       relationship.type() == Relationship::Type::ManyToMany)
    {
        auto &name=relationship.targetTableName();
        auto relationshipClassName=nameTransform(name, true);
        auto originalClassName=nameTransform(relationship.originalTableName(),true);
        if(relationshipClassName!=originalClassName)
        {
	model_cc_tmp_stream << "#include \"";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << ".h\"\n";
        }
    }
    if(relationship.type() == Relationship::Type::ManyToMany)
    {
        auto &pivotTableName=relationship.pivotTable().tableName();
        auto pivotTableClassName=nameTransform(pivotTableName, true);
	model_cc_tmp_stream << "#include \"";
model_cc_tmp_stream<<pivotTableClassName;
	model_cc_tmp_stream << ".h\"\n";
    }
}
	model_cc_tmp_stream << "#include <drogon/utils/Utilities.h>\n";
	model_cc_tmp_stream << "#include <string>\n";
    const auto &cols=model_cc_view_data.get<std::vector<ColumnInfo>>("columns");
    auto className=model_cc_view_data.get<std::string>("className");
    std::string indentStr(model_cc_view_data.get<std::string>("className").length(), ' ');
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "using namespace drogon;\n";
	model_cc_tmp_stream << "using namespace drogon_model::";
{
    auto & val=model_cc_view_data["dbName"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
auto &schema=model_cc_view_data.get<std::string>("schema");
if(!schema.empty())
{
    model_cc_tmp_stream<<"::"<<schema<<";\n";
}
else
{
    model_cc_tmp_stream<<";\n";
}
model_cc_tmp_stream<<"\n";
for(auto col:cols){
	model_cc_tmp_stream << "const std::string ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::Cols::_";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << " = \"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\";\n";
}
if(model_cc_view_data.get<int>("hasPrimaryKey")<=1){
	model_cc_tmp_stream << "const std::string ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::primaryKeyName = \"";
{
    auto & val=model_cc_view_data["primaryKeyName"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "\";\n";
}else{
	model_cc_tmp_stream << "const std::vector<std::string> ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::primaryKeyName = {";
auto pkName=model_cc_view_data.get<std::vector<std::string>>("primaryKeyName");
for(size_t i=0;i<pkName.size();i++)
{
    model_cc_tmp_stream<<"\""<<pkName[i]<<"\"";
    if(i<(pkName.size()-1))
        model_cc_tmp_stream<<",";
}
	model_cc_tmp_stream << "};\n";
}
 if(model_cc_view_data.get<int>("hasPrimaryKey")>0){
	model_cc_tmp_stream << "const bool ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::hasPrimaryKey = true;\n";
 }else{
	model_cc_tmp_stream << "const bool ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::hasPrimaryKey = false;\n";
}
	model_cc_tmp_stream << "const std::string ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::tableName = \"";
if(!schema.empty())
{
    model_cc_tmp_stream<<schema<<".";
}
{
    auto & val=model_cc_view_data["tableName"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "\";\n";
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "const std::vector<typename ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::MetaData> ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::metaData_={\n";
for(size_t i=0;i<cols.size();i++){
    auto &col=cols[i];
model_cc_tmp_stream<<"{\""<<col.colName_<<"\",\""<<col.colType_<<"\",\""<<col.colDatabaseType_<<"\","<<col.colLength_<<","<<col.isAutoVal_<<","<<col.isPrimaryKey_<<","<<col.notNull_<<"}";
if(i<(cols.size()-1))
model_cc_tmp_stream<<",\n";
else
model_cc_tmp_stream<<"\n";
}
	model_cc_tmp_stream << "};\n";
	model_cc_tmp_stream << "const std::string &";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::getColumnName(size_t index) noexcept(false)\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    assert(index < metaData_.size());\n";
	model_cc_tmp_stream << "    return metaData_[index].colName_;\n";
	model_cc_tmp_stream << "}\n";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "(const Row &r, const ssize_t indexOffset) noexcept\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    if(indexOffset < 0)\n";
	model_cc_tmp_stream << "    {\n";
    for(size_t i = 0; i <cols.size(); ++i)
    {
        auto &col = cols[i];
        if(col.colType_.empty())
            continue;
	model_cc_tmp_stream << "        if(!r[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"].isNull())\n";
	model_cc_tmp_stream << "        {\n";
            if(col.colDatabaseType_=="date")
            {
                model_cc_tmp_stream<<"            auto daysStr = r[\""<<col.colName_<<"\"].as<std::string>();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            strptime(daysStr.c_str(),\"%Y-%m-%d\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000);\n";
                model_cc_tmp_stream<<"        }\n";
                continue;
            }
            else if(col.colDatabaseType_.find("timestamp")!=std::string::npos||col.colDatabaseType_.find("datetime")!=std::string::npos)
            {
                model_cc_tmp_stream<<"            auto timeStr = r[\""<<col.colName_<<"\"].as<std::string>();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            auto p = strptime(timeStr.c_str(),\"%Y-%m-%d %H:%M:%S\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
                model_cc_tmp_stream<<"            size_t decimalNum = 0;\n";
                model_cc_tmp_stream<<"            if(*p=='.')\n";
                model_cc_tmp_stream<<"            {\n";
                model_cc_tmp_stream<<"                std::string decimals(p+1,&timeStr[timeStr.length()]);\n";
                model_cc_tmp_stream<<"                while(decimals.length()<6)\n";
                model_cc_tmp_stream<<"                {\n";
                model_cc_tmp_stream<<"                    decimals += \"0\";\n";
                model_cc_tmp_stream<<"                }\n";
                model_cc_tmp_stream<<"                decimalNum = (size_t)atol(decimals.c_str());\n";
                model_cc_tmp_stream<<"            }\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);\n";
                model_cc_tmp_stream<<"        }\n";
                continue;
            } 
            else if(col.colDatabaseType_=="bytea")
            {
                model_cc_tmp_stream<<"            auto str = r[\""<<col.colName_<<"\"].as<string_view>();\n";
                model_cc_tmp_stream<<"            if(str.length()>=2&&\n";
                model_cc_tmp_stream<<"                str[0]=='\\\\'&&str[1]=='x')\n";
                model_cc_tmp_stream<<"            {\n";
                model_cc_tmp_stream<<"                "<<col.colValName_<<"_=std::make_shared<std::vector<char>>(drogon::utils::hexToBinaryVector(str.data()+2,str.length()-2));\n";
                model_cc_tmp_stream<<"            }\n";
                model_cc_tmp_stream<<"        }\n";
                continue;
            }           
	model_cc_tmp_stream << "            ";
model_cc_tmp_stream<<col.colValName_;
	model_cc_tmp_stream << "_=std::make_shared<";
model_cc_tmp_stream<<col.colType_;
	model_cc_tmp_stream << ">(r[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"].as<";
model_cc_tmp_stream<<col.colType_;
	model_cc_tmp_stream << ">());\n";
	model_cc_tmp_stream << "        }\n";
}
	model_cc_tmp_stream << "    }\n";
	model_cc_tmp_stream << "    else\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        size_t offset = (size_t)indexOffset;\n";
	model_cc_tmp_stream << "        if(offset + ";
model_cc_tmp_stream<<cols.size();
	model_cc_tmp_stream << " > r.size())\n";
	model_cc_tmp_stream << "        {\n";
	model_cc_tmp_stream << "            LOG_FATAL << \"Invalid SQL result for this model\";\n";
	model_cc_tmp_stream << "            return;\n";
	model_cc_tmp_stream << "        }\n";
	model_cc_tmp_stream << "        size_t index;\n";
    for(size_t i = 0; i <cols.size(); ++i)
    {
        auto &col = cols[i];
        if(col.colType_.empty())
            continue;
	model_cc_tmp_stream << "        index = offset + ";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << ";\n";
	model_cc_tmp_stream << "        if(!r[index].isNull())\n";
	model_cc_tmp_stream << "        {\n";
            if(col.colDatabaseType_=="date")
            {
                model_cc_tmp_stream<<"            auto daysStr = r[index].as<std::string>();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            strptime(daysStr.c_str(),\"%Y-%m-%d\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000);\n";
                model_cc_tmp_stream<<"        }\n";
                continue;
            }
            else if(col.colDatabaseType_.find("timestamp")!=std::string::npos||col.colDatabaseType_.find("datetime")!=std::string::npos)
            {
                model_cc_tmp_stream<<"            auto timeStr = r[index].as<std::string>();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            auto p = strptime(timeStr.c_str(),\"%Y-%m-%d %H:%M:%S\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
                model_cc_tmp_stream<<"            size_t decimalNum = 0;\n";
                model_cc_tmp_stream<<"            if(*p=='.')\n";
                model_cc_tmp_stream<<"            {\n";
                model_cc_tmp_stream<<"                std::string decimals(p+1,&timeStr[timeStr.length()]);\n";
                model_cc_tmp_stream<<"                while(decimals.length()<6)\n";
                model_cc_tmp_stream<<"                {\n";
                model_cc_tmp_stream<<"                    decimals += \"0\";\n";
                model_cc_tmp_stream<<"                }\n";
                model_cc_tmp_stream<<"                decimalNum = (size_t)atol(decimals.c_str());\n";
                model_cc_tmp_stream<<"            }\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);\n";
                model_cc_tmp_stream<<"        }\n";
                continue;
            } 
            else if(col.colDatabaseType_=="bytea")
            {
                model_cc_tmp_stream<<"            auto str = r[index].as<string_view>();\n";
                model_cc_tmp_stream<<"            if(str.length()>=2&&\n";
                model_cc_tmp_stream<<"                str[0]=='\\\\'&&str[1]=='x')\n";
                model_cc_tmp_stream<<"            {\n";
                model_cc_tmp_stream<<"                "<<col.colValName_<<"_=std::make_shared<std::vector<char>>(drogon::utils::hexToBinaryVector(str.data()+2,str.length()-2));\n";
                model_cc_tmp_stream<<"            }\n";
                model_cc_tmp_stream<<"        }\n";
                continue;
            }           
	model_cc_tmp_stream << "            ";
model_cc_tmp_stream<<col.colValName_;
	model_cc_tmp_stream << "_=std::make_shared<";
model_cc_tmp_stream<<col.colType_;
	model_cc_tmp_stream << ">(r[index].as<";
model_cc_tmp_stream<<col.colType_;
	model_cc_tmp_stream << ">());\n";
	model_cc_tmp_stream << "        }\n";
}
	model_cc_tmp_stream << "    }\n";
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "}\n";
model_cc_tmp_stream<<"\n";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "(const Json::Value &pJson, const std::vector<std::string> &pMasqueradingVector) noexcept(false)\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    if(pMasqueradingVector.size() != ";
model_cc_tmp_stream<<cols.size();
	model_cc_tmp_stream << ")\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        LOG_ERROR << \"Bad masquerading vector\";\n";
	model_cc_tmp_stream << "        return;\n";
	model_cc_tmp_stream << "    }\n";
    for(size_t i=0; i<cols.size(); ++i)
    {
        auto &col = cols[i];        
        if(col.colType_.empty())
            continue;
	model_cc_tmp_stream << "    if(!pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "].empty() && pJson.isMember(pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]))\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        dirtyFlag_[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "] = true;\n";
            if(col.colType_ == "std::string")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<std::string>(pJson[pMasqueradingVector["<<i<<"]].asString());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colDatabaseType_=="date")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto daysStr = pJson[pMasqueradingVector["<<i<<"]].asString();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            strptime(daysStr.c_str(),\"%Y-%m-%d\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000);\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colDatabaseType_.find("timestamp")!=std::string::npos||col.colDatabaseType_.find("datetime")!=std::string::npos)
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto timeStr = pJson[pMasqueradingVector["<<i<<"]].asString();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            auto p = strptime(timeStr.c_str(),\"%Y-%m-%d %H:%M:%S\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
                model_cc_tmp_stream<<"            size_t decimalNum = 0;\n";
                model_cc_tmp_stream<<"            if(*p=='.')\n";
                model_cc_tmp_stream<<"            {\n";
                model_cc_tmp_stream<<"                std::string decimals(p+1,&timeStr[timeStr.length()]);\n";
                model_cc_tmp_stream<<"                while(decimals.length()<6)\n";
                model_cc_tmp_stream<<"                {\n";
                model_cc_tmp_stream<<"                    decimals += \"0\";\n";
                model_cc_tmp_stream<<"                }\n";
                model_cc_tmp_stream<<"                decimalNum = (size_t)atol(decimals.c_str());\n";
                model_cc_tmp_stream<<"            }\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            } 
            else if(col.colDatabaseType_=="bytea" || col.colDatabaseType_.find("blob") != std::string::npos)
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto str = pJson[pMasqueradingVector["<<i<<"]].asString();\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<std::vector<char>>(drogon::utils::base64DecodeToVector(str));\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            } 
            else if(col.colType_.find("uint") == 0 || col.colType_ == "unsigned short")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<"<<col.colType_<<">(("<<col.colType_<<")pJson[pMasqueradingVector["<<i<<"]].asUInt64());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_.find("int") == 0 || col.colType_ == "short")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<"<<col.colType_<<">(("<<col.colType_<<")pJson[pMasqueradingVector["<<i<<"]].asInt64());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_ == "float")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<float>(pJson[pMasqueradingVector["<<i<<"]].asFloat());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"     }\n";
                continue;
            }
            else if(col.colType_ == "double")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<double>(pJson[pMasqueradingVector["<<i<<"]].asDouble());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_ == "bool")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<bool>(pJson[pMasqueradingVector["<<i<<"]].asBool());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }      
	model_cc_tmp_stream << "        }\n";
   
    }
	model_cc_tmp_stream << "}\n";
model_cc_tmp_stream<<"\n";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "(const Json::Value &pJson) noexcept(false)\n";
	model_cc_tmp_stream << "{\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto &col = cols[i];
        if(col.colType_.empty())
            continue;
	model_cc_tmp_stream << "    if(pJson.isMember(\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"))\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        dirtyFlag_[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]=true;\n";
            if(col.colType_ == "std::string")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<std::string>(pJson[\""<<col.colName_<<"\"].asString());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colDatabaseType_=="date")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto daysStr = pJson[\""<<col.colName_<<"\"].asString();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            strptime(daysStr.c_str(),\"%Y-%m-%d\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000);\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colDatabaseType_.find("timestamp")!=std::string::npos||col.colDatabaseType_.find("datetime")!=std::string::npos)
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto timeStr = pJson[\""<<col.colName_<<"\"].asString();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            auto p = strptime(timeStr.c_str(),\"%Y-%m-%d %H:%M:%S\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
                model_cc_tmp_stream<<"            size_t decimalNum = 0;\n";
                model_cc_tmp_stream<<"            if(*p=='.')\n";
                model_cc_tmp_stream<<"            {\n";
                model_cc_tmp_stream<<"                std::string decimals(p+1,&timeStr[timeStr.length()]);\n";
                model_cc_tmp_stream<<"                while(decimals.length()<6)\n";
                model_cc_tmp_stream<<"                {\n";
                model_cc_tmp_stream<<"                    decimals += \"0\";\n";
                model_cc_tmp_stream<<"                }\n";
                model_cc_tmp_stream<<"                decimalNum = (size_t)atol(decimals.c_str());\n";
                model_cc_tmp_stream<<"            }\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);\n";
                 model_cc_tmp_stream<<"        }\n";               
                model_cc_tmp_stream<<"    }\n";
                continue;
            } 
            else if(col.colDatabaseType_=="bytea" || col.colDatabaseType_.find("blob") != std::string::npos)
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto str = pJson[\""<<col.colName_<<"\"].asString();\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<std::vector<char>>(drogon::utils::base64DecodeToVector(str));\n";
                model_cc_tmp_stream<<"        }\n";                
                model_cc_tmp_stream<<"    }\n";
                continue;
            } 
            else if(col.colType_.find("uint") == 0 || col.colType_ == "unsigned short")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<"<<col.colType_<<">(("<<col.colType_<<")pJson[\""<<col.colName_<<"\"].asUInt64());\n";
                model_cc_tmp_stream<<"        }\n";                 
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_.find("int") == 0 || col.colType_ == "short")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<"<<col.colType_<<">(("<<col.colType_<<")pJson[\""<<col.colName_<<"\"].asInt64());\n";
                model_cc_tmp_stream<<"        }\n";                  
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_ == "float")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<float>(pJson[\""<<col.colName_<<"\"].asFloat());\n";
                model_cc_tmp_stream<<"        }\n";                 
                model_cc_tmp_stream<<"     }\n";
                continue;
            }
            else if(col.colType_ == "double")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<double>(pJson[\""<<col.colName_<<"\"].asDouble());\n";
                model_cc_tmp_stream<<"        }\n";                 
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_ == "bool")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<bool>(pJson[\""<<col.colName_<<"\"].asBool());\n";
                model_cc_tmp_stream<<"        }\n";  
                model_cc_tmp_stream<<"    }\n";
                continue;
            }      
	model_cc_tmp_stream << "    }\n";
    }
    
	model_cc_tmp_stream << "}\n";
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "void ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::updateByMasqueradedJson(const Json::Value &pJson,\n";
	model_cc_tmp_stream << "                                            const std::vector<std::string> &pMasqueradingVector) noexcept(false)\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    if(pMasqueradingVector.size() != ";
model_cc_tmp_stream<<cols.size();
	model_cc_tmp_stream << ")\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        LOG_ERROR << \"Bad masquerading vector\";\n";
	model_cc_tmp_stream << "        return;\n";
	model_cc_tmp_stream << "    }\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto &col = cols[i];
        if(col.colType_.empty())
            continue;
	model_cc_tmp_stream << "    if(!pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "].empty() && pJson.isMember(pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]))\n";
	model_cc_tmp_stream << "    {\n";
            if(!col.isAutoVal_ && !col.isPrimaryKey_)
            {
                model_cc_tmp_stream<<"        dirtyFlag_["<<i<<"] = true;\n";
            }
            if(col.colType_ == "std::string")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<std::string>(pJson[pMasqueradingVector["<<i<<"]].asString());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colDatabaseType_=="date")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto daysStr = pJson[pMasqueradingVector["<<i<<"]].asString();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            strptime(daysStr.c_str(),\"%Y-%m-%d\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000);\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colDatabaseType_.find("timestamp")!=std::string::npos||col.colDatabaseType_.find("datetime")!=std::string::npos)
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto timeStr = pJson[pMasqueradingVector["<<i<<"]].asString();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            auto p = strptime(timeStr.c_str(),\"%Y-%m-%d %H:%M:%S\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
                model_cc_tmp_stream<<"            size_t decimalNum = 0;\n";
                model_cc_tmp_stream<<"            if(*p=='.')\n";
                model_cc_tmp_stream<<"            {\n";
                model_cc_tmp_stream<<"                std::string decimals(p+1,&timeStr[timeStr.length()]);\n";
                model_cc_tmp_stream<<"                while(decimals.length()<6)\n";
                model_cc_tmp_stream<<"                {\n";
                model_cc_tmp_stream<<"                    decimals += \"0\";\n";
                model_cc_tmp_stream<<"                }\n";
                model_cc_tmp_stream<<"                decimalNum = (size_t)atol(decimals.c_str());\n";
                model_cc_tmp_stream<<"            }\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            } 
            else if(col.colDatabaseType_=="bytea" || col.colDatabaseType_.find("blob") != std::string::npos)
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto str = pJson[pMasqueradingVector["<<i<<"]].asString();\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<std::vector<char>>(drogon::utils::base64DecodeToVector(str));\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            } 
            else if(col.colType_.find("uint") == 0 || col.colType_ == "unsigned short")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<"<<col.colType_<<">(("<<col.colType_<<")pJson[pMasqueradingVector["<<i<<"]].asUInt64());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_.find("int") == 0 || col.colType_ == "short")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<"<<col.colType_<<">(("<<col.colType_<<")pJson[pMasqueradingVector["<<i<<"]].asInt64());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_ == "float")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<float>(pJson[pMasqueradingVector["<<i<<"]].asFloat());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_ == "double")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<double>(pJson[pMasqueradingVector["<<i<<"]].asDouble());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_ == "bool")
            {
                model_cc_tmp_stream<<"        if(!pJson[pMasqueradingVector["<<i<<"]].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<bool>(pJson[pMasqueradingVector["<<i<<"]].asBool());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }      
	model_cc_tmp_stream << "        }\n";
    }
    
	model_cc_tmp_stream << "}\n";
	model_cc_tmp_stream << "                                                                    \n";
	model_cc_tmp_stream << "void ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::updateByJson(const Json::Value &pJson) noexcept(false)\n";
	model_cc_tmp_stream << "{\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto &col = cols[i];
        if(col.colType_.empty())
            continue;
        
	model_cc_tmp_stream << "    if(pJson.isMember(\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"))\n";
	model_cc_tmp_stream << "    {\n";
            if(!col.isAutoVal_ && !col.isPrimaryKey_)
            {
                model_cc_tmp_stream<<"        dirtyFlag_["<<i<<"] = true;\n";
            }
            if(col.colType_ == "std::string")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<std::string>(pJson[\""<<col.colName_<<"\"].asString());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colDatabaseType_=="date")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto daysStr = pJson[\""<<col.colName_<<"\"].asString();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            strptime(daysStr.c_str(),\"%Y-%m-%d\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000);\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colDatabaseType_.find("timestamp")!=std::string::npos||col.colDatabaseType_.find("datetime")!=std::string::npos)
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto timeStr = pJson[\""<<col.colName_<<"\"].asString();\n";
                model_cc_tmp_stream<<"            struct tm stm;\n";
                model_cc_tmp_stream<<"            memset(&stm,0,sizeof(stm));\n";
                model_cc_tmp_stream<<"            auto p = strptime(timeStr.c_str(),\"%Y-%m-%d %H:%M:%S\",&stm);\n";
                model_cc_tmp_stream<<"            time_t t = mktime(&stm);\n";
                model_cc_tmp_stream<<"            size_t decimalNum = 0;\n";
                model_cc_tmp_stream<<"            if(*p=='.')\n";
                model_cc_tmp_stream<<"            {\n";
                model_cc_tmp_stream<<"                std::string decimals(p+1,&timeStr[timeStr.length()]);\n";
                model_cc_tmp_stream<<"                while(decimals.length()<6)\n";
                model_cc_tmp_stream<<"                {\n";
                model_cc_tmp_stream<<"                    decimals += \"0\";\n";
                model_cc_tmp_stream<<"                }\n";
                model_cc_tmp_stream<<"                decimalNum = (size_t)atol(decimals.c_str());\n";
                model_cc_tmp_stream<<"            }\n";
 //               model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            } 
            else if(col.colDatabaseType_=="bytea" || col.colDatabaseType_.find("blob") != std::string::npos)
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            auto str = pJson[\""<<col.colName_<<"\"].asString();\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<std::vector<char>>(drogon::utils::base64DecodeToVector(str));\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            } 
            else if(col.colType_.find("uint") == 0 || col.colType_ == "unsigned short")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<"<<col.colType_<<">(("<<col.colType_<<")pJson[\""<<col.colName_<<"\"].asUInt64());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_.find("int") == 0 || col.colType_ == "short")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<"<<col.colType_<<">(("<<col.colType_<<")pJson[\""<<col.colName_<<"\"].asInt64());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_ == "float")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<float>(pJson[\""<<col.colName_<<"\"].asFloat());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_ == "double")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<double>(pJson[\""<<col.colName_<<"\"].asDouble());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }
            else if(col.colType_ == "bool")
            {
                model_cc_tmp_stream<<"        if(!pJson[\""<<col.colName_<<"\"].isNull())\n";
                model_cc_tmp_stream<<"        {\n";
                model_cc_tmp_stream<<"            "<<col.colValName_<<"_=std::make_shared<bool>(pJson[\""<<col.colName_<<"\"].asBool());\n";
                model_cc_tmp_stream<<"        }\n";
                model_cc_tmp_stream<<"    }\n";
                continue;
            }      
	model_cc_tmp_stream << "        }\n";
    }
    
	model_cc_tmp_stream << "}\n";
model_cc_tmp_stream<<"\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto &col = cols[i];
        if(!col.colType_.empty())
        {
            model_cc_tmp_stream<<"const "<<col.colType_<<" &"<<className<<"::getValueOf"<<col.colTypeName_<<"() const noexcept\n";
            model_cc_tmp_stream<<"{\n";
            model_cc_tmp_stream<<"    const static "<<col.colType_<<" defaultValue = "<<col.colType_<<"();\n";
            model_cc_tmp_stream<<"    if("<<col.colValName_<<"_)\n";
            model_cc_tmp_stream<<"        return *"<<col.colValName_<<"_;\n";
            model_cc_tmp_stream<<"    return defaultValue;\n";
            model_cc_tmp_stream<<"}\n";
            if(col.colType_=="std::vector<char>")
            {
                model_cc_tmp_stream<<"std::string "<<className<<"::getValueOf"<<col.colTypeName_<<"AsString() const noexcept\n";
                model_cc_tmp_stream<<"{\n";
                model_cc_tmp_stream<<"    const static std::string defaultValue = std::string();\n";
                model_cc_tmp_stream<<"    if("<<col.colValName_<<"_)\n";
                model_cc_tmp_stream<<"        return std::string("<<col.colValName_<<"_->data(),"<<col.colValName_<<"_->size());\n";
                model_cc_tmp_stream<<"    return defaultValue;\n";
                model_cc_tmp_stream<<"}\n";
            }
            model_cc_tmp_stream<<"const std::shared_ptr<"<<col.colType_<<"> &"<<className<<"::get"<<col.colTypeName_<<"() const noexcept\n";
            model_cc_tmp_stream<<"{\n";
            model_cc_tmp_stream<<"    return "<<col.colValName_<<"_;\n";
            model_cc_tmp_stream<<"}\n";
 
                model_cc_tmp_stream<<"void "<<className<<"::set"<<col.colTypeName_<<"(const "<<col.colType_<<" &p"<<col.colTypeName_<<") noexcept\n";
                model_cc_tmp_stream<<"{\n";
                if(col.colDatabaseType_=="date")
                {
                    model_cc_tmp_stream<<"    "<<col.colValName_<<"_ = std::make_shared<"<<col.colType_<<">(p"<<col.colTypeName_<<".roundDay());\n";
                }
                else
                {
                    model_cc_tmp_stream<<"    "<<col.colValName_<<"_ = std::make_shared<"<<col.colType_<<">(p"<<col.colTypeName_<<");\n";
                }
                model_cc_tmp_stream<<"    dirtyFlag_["<<i<<"] = true;\n";
                model_cc_tmp_stream<<"}\n";
                
                if(col.colType_=="std::string")
                {
                    model_cc_tmp_stream<<"void "<<className<<"::set"<<col.colTypeName_<<"("<<col.colType_<<" &&p"<<col.colTypeName_<<") noexcept\n";
                    model_cc_tmp_stream<<"{\n";
                    model_cc_tmp_stream<<"    "<<col.colValName_<<"_ = std::make_shared<"<<col.colType_<<">(std::move(p"<<col.colTypeName_<<"));\n";
                    model_cc_tmp_stream<<"    dirtyFlag_["<<i<<"] = true;\n";
                    model_cc_tmp_stream<<"}\n";
                }
model_cc_tmp_stream<<"\n";
                if(col.colType_=="std::vector<char>")
                {
                    model_cc_tmp_stream<<"void "<<className<<"::set"<<col.colTypeName_<<"(const std::string &p"<<col.colTypeName_<<") noexcept\n";
                    model_cc_tmp_stream<<"{\n";
                    model_cc_tmp_stream<<"    "<<col.colValName_<<"_ = std::make_shared<std::vector<char>>(p"<<col.colTypeName_<<".c_str(),p"<<col.colTypeName_<<".c_str()+p"<<col.colTypeName_<<".length());\n";
                    model_cc_tmp_stream<<"    dirtyFlag_["<<i<<"] = true;\n";
                    model_cc_tmp_stream<<"}\n";
                }
model_cc_tmp_stream<<"\n";
                if(!col.notNull_)
                {
                    model_cc_tmp_stream<<"void "<<className<<"::set"<<col.colTypeName_<<"ToNull() noexcept\n";
                    model_cc_tmp_stream<<"{\n";
                    model_cc_tmp_stream<<"    "<<col.colValName_<<"_.reset();\n";
                    model_cc_tmp_stream<<"    dirtyFlag_["<<i<<"] = true;\n";
                    model_cc_tmp_stream<<"}\n";
                }
model_cc_tmp_stream<<"\n";
            if(col.isPrimaryKey_&&model_cc_view_data.get<int>("hasPrimaryKey")==1)
            {
                model_cc_tmp_stream<<"const typename "<<className<<"::PrimaryKeyType & "<<className<<"::getPrimaryKey() const\n";
                model_cc_tmp_stream<<"{\n";
                model_cc_tmp_stream<<"    assert("<<col.colValName_<<"_);\n";
                model_cc_tmp_stream<<"    return *"<<col.colValName_<<"_;\n";
                model_cc_tmp_stream<<"}\n";
            }
        }
        model_cc_tmp_stream<<"\n";    
    }
    if(model_cc_view_data.get<std::string>("rdbms")=="postgresql"||model_cc_view_data.get<int>("hasPrimaryKey")!=1)
    {
        model_cc_tmp_stream<<"void "<<className<<"::updateId(const uint64_t id)\n";
        model_cc_tmp_stream<<"{\n";
        model_cc_tmp_stream<<"}\n";
    }
    else if(model_cc_view_data.get<std::string>("rdbms")=="mysql"||model_cc_view_data.get<std::string>("rdbms")=="sqlite3")
    {
        auto primaryKeyTypeString=model_cc_view_data.get<std::string>("primaryKeyType");
        model_cc_tmp_stream<<"void "<<className<<"::updateId(const uint64_t id)\n";
        model_cc_tmp_stream<<"{\n";
        for(auto col:cols)
        {
            if(col.isAutoVal_)
            {
                if(primaryKeyTypeString!="uint64_t")
                {
                    model_cc_tmp_stream<<"    "<<col.colValName_<<"_ = std::make_shared<"<<primaryKeyTypeString<<">(static_cast<"<<primaryKeyTypeString<<">(id));\n";
                }
                else
                {
                    model_cc_tmp_stream<<"    "<<col.colValName_<<"_ = std::make_shared<uint64_t>(id);\n";
                }
                break;
            }
        }
        model_cc_tmp_stream<<"}\n";
    }
    if(model_cc_view_data.get<int>("hasPrimaryKey")>1)
    {
        model_cc_tmp_stream<<"typename "<<className<<"::PrimaryKeyType "<<className<<"::getPrimaryKey() const\n";
        model_cc_tmp_stream<<"{\n";
        model_cc_tmp_stream<<"    return std::make_tuple(";
        int count=0;
        auto pkNames=model_cc_view_data.get<std::vector<std::string>>("primaryKeyValNames");
        for(auto pkName:pkNames)
        {
            ++count;
            model_cc_tmp_stream<<"*"<<pkName<<"_";
            if(count<model_cc_view_data.get<int>("hasPrimaryKey"))
                model_cc_tmp_stream<<",";
        }
        model_cc_tmp_stream<<");\n";
        model_cc_tmp_stream<<"}\n";
    }
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "const std::vector<std::string> &";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::insertColumns() noexcept\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    static const std::vector<std::string> inCols={\n";
for(size_t i=0;i<cols.size();i++){
    auto col=cols[i];
    if(!col.isAutoVal_&&!col.colType_.empty())
    {
        model_cc_tmp_stream<<"        \""<<col.colName_<<"\"";
        if(i<(cols.size()-1))
            model_cc_tmp_stream<<",\n";
        else
            model_cc_tmp_stream<<"\n";
    }
}
	model_cc_tmp_stream << "    };\n";
	model_cc_tmp_stream << "    return inCols;\n";
	model_cc_tmp_stream << "}\n";
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "void ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::outputArgs(drogon::orm::internal::SqlBinder &binder) const\n";
	model_cc_tmp_stream << "{\n";
for(size_t i = 0; i < cols.size(); ++i){
    auto &col = cols[i];
    if(!col.isAutoVal_&&!col.colType_.empty())
    {
	model_cc_tmp_stream << "    if(dirtyFlag_[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "])\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        if(get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "())\n";
	model_cc_tmp_stream << "        {\n";
	model_cc_tmp_stream << "            binder << getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
	model_cc_tmp_stream << "        }\n";
	model_cc_tmp_stream << "        else\n";
	model_cc_tmp_stream << "        {\n";
	model_cc_tmp_stream << "            binder << nullptr;\n";
	model_cc_tmp_stream << "        }\n";
	model_cc_tmp_stream << "    }\n";
    }
}
	model_cc_tmp_stream << "}\n";
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "const std::vector<std::string> ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::updateColumns() const\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    std::vector<std::string> ret;\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto & col=cols[i];
        if(col.colType_.empty()||col.isAutoVal_)
            continue;
	model_cc_tmp_stream << "    if(dirtyFlag_[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "])\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        ret.push_back(getColumnName(";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "));\n";
	model_cc_tmp_stream << "    }\n";
    }
	model_cc_tmp_stream << "    return ret;\n";
	model_cc_tmp_stream << "}\n";
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "void ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::updateArgs(drogon::orm::internal::SqlBinder &binder) const\n";
	model_cc_tmp_stream << "{\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto & col=cols[i];
        if(col.colType_.empty()||col.isAutoVal_)
            continue;
	model_cc_tmp_stream << "    if(dirtyFlag_[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "])\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        if(get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "())\n";
	model_cc_tmp_stream << "        {\n";
	model_cc_tmp_stream << "            binder << getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
	model_cc_tmp_stream << "        }\n";
	model_cc_tmp_stream << "        else\n";
	model_cc_tmp_stream << "        {\n";
	model_cc_tmp_stream << "            binder << nullptr;\n";
	model_cc_tmp_stream << "        }\n";
	model_cc_tmp_stream << "    }\n";
    }
	model_cc_tmp_stream << "}\n";
	model_cc_tmp_stream << "Json::Value ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::toJson() const\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    Json::Value ret;\n";
for(auto col:cols){
	model_cc_tmp_stream << "    if(get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "())\n";
	model_cc_tmp_stream << "    {\n";
if(col.colDatabaseType_=="date"){
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->toDbStringLocal();\n";
}else if(col.colDatabaseType_.find("timestamp")!=std::string::npos||col.colDatabaseType_.find("datetime")!=std::string::npos){
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->toDbStringLocal();\n";
}else if(col.colDatabaseType_=="bytea"||col.colDatabaseType_.find("blob")!=std::string::npos){
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=drogon::utils::base64Encode((const unsigned char *)get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->data(),get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->size());\n";
}else if(col.colType_=="int64_t"){
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=(Json::Int64)getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
}else if(col.colType_=="uint64_t"){
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=(Json::UInt64)getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
}else{
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
}
	model_cc_tmp_stream << "    }\n";
	model_cc_tmp_stream << "    else\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=Json::Value();\n";
	model_cc_tmp_stream << "    }\n";
}
	model_cc_tmp_stream << "    return ret;\n";
	model_cc_tmp_stream << "}\n";
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "Json::Value ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::toMasqueradedJson(\n";
	model_cc_tmp_stream << "    const std::vector<std::string> &pMasqueradingVector) const\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    Json::Value ret;\n";
	model_cc_tmp_stream << "    if(pMasqueradingVector.size() == ";
model_cc_tmp_stream<<cols.size();
	model_cc_tmp_stream << ")\n";
	model_cc_tmp_stream << "    {\n";
for(size_t i = 0; i < cols.size(); ++i){
    auto &col = cols[i];
    
	model_cc_tmp_stream << "        if(!pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "].empty())\n";
	model_cc_tmp_stream << "        {\n";
	model_cc_tmp_stream << "            if(get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "())\n";
	model_cc_tmp_stream << "            {\n";
if(col.colDatabaseType_=="date"){
	model_cc_tmp_stream << "                ret[pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]]=get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->toDbStringLocal();\n";
}else if(col.colDatabaseType_.find("timestamp")!=std::string::npos||col.colDatabaseType_.find("datetime")!=std::string::npos){
	model_cc_tmp_stream << "                ret[pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]]=get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->toDbStringLocal();\n";
}else if(col.colDatabaseType_=="bytea"||col.colDatabaseType_.find("blob")!=std::string::npos){
	model_cc_tmp_stream << "                ret[pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]]=drogon::utils::base64Encode((const unsigned char *)get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->data(),get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->size());\n";
}else if(col.colType_=="int64_t"){
	model_cc_tmp_stream << "                ret[pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]]=(Json::Int64)getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
}else if(col.colType_=="uint64_t"){
	model_cc_tmp_stream << "                ret[pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]]=(Json::UInt64)getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
}else{
	model_cc_tmp_stream << "                ret[pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]]=getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
}
	model_cc_tmp_stream << "            }\n";
	model_cc_tmp_stream << "            else\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                ret[pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]]=Json::Value();\n";
	model_cc_tmp_stream << "            }\n";
	model_cc_tmp_stream << "        }\n";
}
	model_cc_tmp_stream << "        return ret;\n";
	model_cc_tmp_stream << "    }\n";
	model_cc_tmp_stream << "    LOG_ERROR << \"Masquerade failed\";\n";
for(auto col:cols){
	model_cc_tmp_stream << "    if(get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "())\n";
	model_cc_tmp_stream << "    {\n";
if(col.colDatabaseType_=="date"){
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->toDbStringLocal();\n";
}else if(col.colDatabaseType_.find("timestamp")!=std::string::npos||col.colDatabaseType_.find("datetime")!=std::string::npos){
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->toDbStringLocal();\n";
}else if(col.colDatabaseType_=="bytea"||col.colDatabaseType_.find("blob")!=std::string::npos){
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=drogon::utils::base64Encode((const unsigned char *)get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->data(),get";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "()->size());\n";
}else if(col.colType_=="int64_t"){
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=(Json::Int64)getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
}else if(col.colType_=="uint64_t"){
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=(Json::UInt64)getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
}else{
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=getValueOf";
model_cc_tmp_stream<<col.colTypeName_;
	model_cc_tmp_stream << "();\n";
}
	model_cc_tmp_stream << "    }\n";
	model_cc_tmp_stream << "    else\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        ret[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"]=Json::Value();\n";
	model_cc_tmp_stream << "    }\n";
}
	model_cc_tmp_stream << "    return ret;\n";
	model_cc_tmp_stream << "}\n";
model_cc_tmp_stream<<"\n";
	model_cc_tmp_stream << "bool ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::validateJsonForCreation(const Json::Value &pJson, std::string &err)\n";
	model_cc_tmp_stream << "{\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto &col = cols[i];
        if(col.colType_.empty())
            continue;
	model_cc_tmp_stream << "    if(pJson.isMember(\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"))\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        if(!validJsonOfField(";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << ", \"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\", pJson[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"], err, true))\n";
	model_cc_tmp_stream << "            return false;\n";
	model_cc_tmp_stream << "    }\n";
if(col.notNull_ && !col.isAutoVal_ && !col.hasDefaultVal_){
	model_cc_tmp_stream << "    else\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        err=\"The ";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << " column cannot be null\";\n";
	model_cc_tmp_stream << "        return false;\n";
	model_cc_tmp_stream << "    }\n";
}
}
	model_cc_tmp_stream << "    return true;\n";
	model_cc_tmp_stream << "}\n";
	model_cc_tmp_stream << "bool ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::validateMasqueradedJsonForCreation(const Json::Value &pJson,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "                                     const std::vector<std::string> &pMasqueradingVector,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "                                     std::string &err)\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    if(pMasqueradingVector.size() != ";
model_cc_tmp_stream<<cols.size();
	model_cc_tmp_stream << ")\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        err = \"Bad masquerading vector\";\n";
	model_cc_tmp_stream << "        return false;\n";
	model_cc_tmp_stream << "    }\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto &col = cols[i];
        if(col.colType_.empty())
            continue;
	model_cc_tmp_stream << "    if(!pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "].empty())\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        if(pJson.isMember(pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]))\n";
	model_cc_tmp_stream << "        {\n";
	model_cc_tmp_stream << "            if(!validJsonOfField(";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << ", pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "], pJson[pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]], err, true))\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "        }\n";
if(col.notNull_ && !col.isAutoVal_ && !col.hasDefaultVal_){
	model_cc_tmp_stream << "        else\n";
	model_cc_tmp_stream << "        {\n";
	model_cc_tmp_stream << "            err=\"The \" + pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "] + \" column cannot be null\";\n";
	model_cc_tmp_stream << "            return false;\n";
	model_cc_tmp_stream << "        }\n";
}
	model_cc_tmp_stream << "    }\n";
}
	model_cc_tmp_stream << "    return true;\n";
	model_cc_tmp_stream << "}\n";
	model_cc_tmp_stream << "bool ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::validateJsonForUpdate(const Json::Value &pJson, std::string &err)\n";
	model_cc_tmp_stream << "{\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto &col = cols[i];
        if(col.colType_.empty())
            continue;
	model_cc_tmp_stream << "    if(pJson.isMember(\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"))\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        if(!validJsonOfField(";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << ", \"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\", pJson[\"";
model_cc_tmp_stream<<col.colName_;
	model_cc_tmp_stream << "\"], err, false))\n";
	model_cc_tmp_stream << "            return false;\n";
	model_cc_tmp_stream << "    }\n";
    if(col.isPrimaryKey_)
    {
	model_cc_tmp_stream << "    else\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        err = \"The value of primary key must be set in the json object for update\";\n";
	model_cc_tmp_stream << "        return false;\n";
	model_cc_tmp_stream << "    }\n";
        
    }
}
	model_cc_tmp_stream << "    return true;\n";
	model_cc_tmp_stream << "}\n";
	model_cc_tmp_stream << "bool ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::validateMasqueradedJsonForUpdate(const Json::Value &pJson,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "                                   const std::vector<std::string> &pMasqueradingVector,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "                                   std::string &err)\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    if(pMasqueradingVector.size() != ";
model_cc_tmp_stream<<cols.size();
	model_cc_tmp_stream << ")\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        err = \"Bad masquerading vector\";\n";
	model_cc_tmp_stream << "        return false;\n";
	model_cc_tmp_stream << "    }\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto &col = cols[i];
        if(col.colType_.empty())
            continue;
	model_cc_tmp_stream << "    if(!pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "].empty() && pJson.isMember(pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]))\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        if(!validJsonOfField(";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << ", pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "], pJson[pMasqueradingVector[";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << "]], err, false))\n";
	model_cc_tmp_stream << "            return false;\n";
	model_cc_tmp_stream << "    }\n";
    
    if(col.isPrimaryKey_)
    {
	model_cc_tmp_stream << "    else\n";
	model_cc_tmp_stream << "    {\n";
	model_cc_tmp_stream << "        err = \"The value of primary key must be set in the json object for update\";\n";
	model_cc_tmp_stream << "        return false;\n";
	model_cc_tmp_stream << "    }\n";
        
    }
}
	model_cc_tmp_stream << "    return true;\n";
	model_cc_tmp_stream << "}\n";
	model_cc_tmp_stream << "bool ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::validJsonOfField(size_t index,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "                   const std::string &fieldName,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "                   const Json::Value &pJson, \n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "                   std::string &err, \n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "                   bool isForCreation)\n";
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    switch(index)\n";
	model_cc_tmp_stream << "    {\n";
    for(size_t i=0;i<cols.size();i++)
    {
        auto &col = cols[i];
        if(col.colType_.empty())
            continue;
	model_cc_tmp_stream << "        case ";
model_cc_tmp_stream<<i;
	model_cc_tmp_stream << ":\n";
if(col.notNull_){
	model_cc_tmp_stream << "            if(pJson.isNull())\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"The \" + fieldName + \" column cannot be null\";\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "            }\n";
}
            if(col.isAutoVal_)
            {  
                if(col.isPrimaryKey_)
                {
	model_cc_tmp_stream << "            if(isForCreation)\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"The automatic primary key cannot be set\";\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "            }        \n";
                    
                }else
                {
	model_cc_tmp_stream << "            if(isForCreation)\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"The automatic primary key cannot be set\";\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "            }\n";
	model_cc_tmp_stream << "            else\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"The automatic primary key cannot be update\";\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "            }\n";
                    
                }
            } 
if(!col.notNull_){
	model_cc_tmp_stream << "            if(pJson.isNull())\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                return true;\n";
	model_cc_tmp_stream << "            }\n";
}            
            if(col.colType_ == "uint64_t")
            {
	model_cc_tmp_stream << "            if(!pJson.isUInt64())\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"Type error in the \"+fieldName+\" field\";\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "            }\n";
            }
            else if(col.colType_ == "int64_t")
            {
	model_cc_tmp_stream << "            if(!pJson.isInt64())\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"Type error in the \"+fieldName+\" field\";\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "            }\n";
            }
            else if(col.colType_.find("uint") == 0)
            {
	model_cc_tmp_stream << "            if(!pJson.isUInt())\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"Type error in the \"+fieldName+\" field\";\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "            }\n";
            }
            else if(col.colType_.find("int") == 0)
            {
	model_cc_tmp_stream << "            if(!pJson.isInt())\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"Type error in the \"+fieldName+\" field\";\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "            }\n";
            }
            else if(col.colType_ == "float" || col.colType_ == "double")
            {
	model_cc_tmp_stream << "            if(!pJson.isNumeric())\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"Type error in the \"+fieldName+\" field\";\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "            }\n";
            }
            else if(col.colType_ == "bool")
            {
	model_cc_tmp_stream << "            if(!pJson.isBool())\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"Type error in the \"+fieldName+\" field\";\n";
	model_cc_tmp_stream << "                return false;\n";
	model_cc_tmp_stream << "            }\n";
               
            }
            else
            {
	model_cc_tmp_stream << "            if(!pJson.isString())\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"Type error in the \"+fieldName+\" field\";\n";
	model_cc_tmp_stream << "                return false;                \n";
	model_cc_tmp_stream << "            }\n";
                if(col.colType_ == "std::string" && col.colLength_>0)
                {
	model_cc_tmp_stream << "            // asString().length() creates a string object, is there any better way to validate the length?\n";
	model_cc_tmp_stream << "            if(pJson.isString() && pJson.asString().length() > ";
model_cc_tmp_stream<<col.colLength_;
	model_cc_tmp_stream << ")\n";
	model_cc_tmp_stream << "            {\n";
	model_cc_tmp_stream << "                err=\"String length exceeds limit for the \" +\n";
	model_cc_tmp_stream << "                    fieldName +\n";
	model_cc_tmp_stream << "                    \" field (the maximum value is ";
model_cc_tmp_stream<<col.colLength_;
	model_cc_tmp_stream << ")\";\n";
	model_cc_tmp_stream << "                return false;               \n";
	model_cc_tmp_stream << "            }\n";
model_cc_tmp_stream<<"\n";
                }
            }
	model_cc_tmp_stream << "            break;\n";
}
	model_cc_tmp_stream << "     \n";
	model_cc_tmp_stream << "        default:\n";
	model_cc_tmp_stream << "            err=\"Internal error in the server\";\n";
	model_cc_tmp_stream << "            return false;\n";
	model_cc_tmp_stream << "            break;\n";
	model_cc_tmp_stream << "    }\n";
	model_cc_tmp_stream << "    return true;\n";
	model_cc_tmp_stream << "}\n";
for(auto &relationship : relationships)
{
    if(relationship.targetKey().empty() || relationship.originalKey().empty())
        {
            continue;
        }
        auto &name=relationship.targetTableName();
        auto relationshipClassName=nameTransform(name, true);
        auto relationshipValName=nameTransform(name, false);
        auto alias=relationship.targetTableAlias();
        auto aliasValName=nameTransform(alias, false);
        if(relationship.type() == Relationship::Type::HasOne)
        {
            if(!alias.empty())
            {
                if(alias[0] <= 'z' && alias[0] >= 'a')
                {
                    alias[0] += ('A' - 'a');
                }
                std::string alind(alias.length(), ' ');
	model_cc_tmp_stream << "void ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::get";
model_cc_tmp_stream<<alias;
	model_cc_tmp_stream << "(const DbClientPtr &clientPtr, \n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<alind;
	model_cc_tmp_stream << " const std::function<void(";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << ")> &rcb,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<alind;
	model_cc_tmp_stream << " const ExceptionCallback &ecb) const\n";
            }
            else
            {
                std::string relationshipClassInde(relationshipClassName.length(), ' ');
	model_cc_tmp_stream << "void ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::get";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << "(const DbClientPtr &clientPtr, \n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<relationshipClassInde;
	model_cc_tmp_stream << " const std::function<void(";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << ")> &rcb,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<relationshipClassInde;
	model_cc_tmp_stream << " const ExceptionCallback &ecb) const\n";
            }
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    const static std::string sql = \"select * from ";
model_cc_tmp_stream<<name;
	model_cc_tmp_stream << " where ";
model_cc_tmp_stream<<relationship.targetKey();
	model_cc_tmp_stream << " = ";
            if(rdbms=="postgresql")
            {
                model_cc_tmp_stream<<"$1";
            }
            else
            {
                model_cc_tmp_stream<<"?";
            }
	model_cc_tmp_stream << "\";\n";
	model_cc_tmp_stream << "    *clientPtr << sql\n";
	model_cc_tmp_stream << "               << *";
model_cc_tmp_stream<<nameTransform(relationship.originalKey(), false);
	model_cc_tmp_stream << "_ \n";
	model_cc_tmp_stream << "               >> [rcb = std::move(rcb), ecb](const Result &r){\n";
	model_cc_tmp_stream << "                    if (r.size() == 0)\n";
	model_cc_tmp_stream << "                    {\n";
	model_cc_tmp_stream << "                        ecb(UnexpectedRows(\"0 rows found\"));\n";
	model_cc_tmp_stream << "                    }\n";
	model_cc_tmp_stream << "                    else if (r.size() > 1)\n";
	model_cc_tmp_stream << "                    {\n";
	model_cc_tmp_stream << "                        ecb(UnexpectedRows(\"Found more than one row\"));\n";
	model_cc_tmp_stream << "                    }\n";
	model_cc_tmp_stream << "                    else\n";
	model_cc_tmp_stream << "                    {\n";
	model_cc_tmp_stream << "                        rcb(";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << "(r[0]));\n";
	model_cc_tmp_stream << "                    }\n";
	model_cc_tmp_stream << "               }\n";
	model_cc_tmp_stream << "               >> ecb;\n";
	model_cc_tmp_stream << "}\n";
        }
        else if(relationship.type() == Relationship::Type::HasMany)
        {
            if(!alias.empty())
            {
                if(alias[0] <= 'z' && alias[0] >= 'a')
                {
                    alias[0] += ('A' - 'a');
                }
                std::string alind(alias.length(), ' ');
	model_cc_tmp_stream << "void ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::get";
model_cc_tmp_stream<<alias;
	model_cc_tmp_stream << "(const DbClientPtr &clientPtr, \n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<alind;
	model_cc_tmp_stream << " const std::function<void(std::vector<";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << ">)> &rcb,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<alind;
	model_cc_tmp_stream << " const ExceptionCallback &ecb) const\n";
            }
            else
            {
                std::string relationshipClassInde(relationshipClassName.length(), ' ');
	model_cc_tmp_stream << "void ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::get";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << "(const DbClientPtr &clientPtr, \n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<relationshipClassInde;
	model_cc_tmp_stream << " const std::function<void(std::vector<";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << ">)> &rcb,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<relationshipClassInde;
	model_cc_tmp_stream << " const ExceptionCallback &ecb) const\n";
            }
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    const static std::string sql = \"select * from ";
model_cc_tmp_stream<<name;
	model_cc_tmp_stream << " where ";
model_cc_tmp_stream<<relationship.targetKey();
	model_cc_tmp_stream << " = ";
            if(rdbms=="postgresql")
            {
                model_cc_tmp_stream<<"$1";
            }
            else
            {
                model_cc_tmp_stream<<"?";
            }
	model_cc_tmp_stream << "\";\n";
	model_cc_tmp_stream << "    *clientPtr << sql\n";
	model_cc_tmp_stream << "               << *";
model_cc_tmp_stream<<nameTransform(relationship.originalKey(), false);
	model_cc_tmp_stream << "_ \n";
	model_cc_tmp_stream << "               >> [rcb = std::move(rcb)](const Result &r){\n";
	model_cc_tmp_stream << "                   std::vector<";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << "> ret;\n";
	model_cc_tmp_stream << "                   ret.reserve(ret.size());\n";
	model_cc_tmp_stream << "                   for (auto const &row : r)\n";
	model_cc_tmp_stream << "                   {\n";
	model_cc_tmp_stream << "                       ret.emplace_back(";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << "(row));\n";
	model_cc_tmp_stream << "                   }\n";
	model_cc_tmp_stream << "                   rcb(ret);\n";
	model_cc_tmp_stream << "               }\n";
	model_cc_tmp_stream << "               >> ecb;\n";
	model_cc_tmp_stream << "}\n";
        }
        else if(relationship.type() == Relationship::Type::ManyToMany)
        {
            auto &pivotTableName=relationship.pivotTable().tableName();
            auto pivotTableClassName=nameTransform(pivotTableName, true);
            auto &pivotOriginalKey=relationship.pivotTable().originalKey();
            auto &pivotTargetKey=relationship.pivotTable().targetKey();
            if(!alias.empty())
            {
                if(alias[0] <= 'z' && alias[0] >= 'a')
                {
                    alias[0] += ('A' - 'a');
                }
                std::string alind(alias.length(), ' ');
	model_cc_tmp_stream << "void ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::get";
model_cc_tmp_stream<<alias;
	model_cc_tmp_stream << "(const DbClientPtr &clientPtr, \n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<alind;
	model_cc_tmp_stream << " const std::function<void(std::vector<std::pair<";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << ",";
model_cc_tmp_stream<<pivotTableClassName;
	model_cc_tmp_stream << ">>)> &rcb,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<alind;
	model_cc_tmp_stream << " const ExceptionCallback &ecb) const\n";
            }
            else
            {
                std::string relationshipClassInde(relationshipClassName.length(), ' ');
	model_cc_tmp_stream << "void ";
{
    auto & val=model_cc_view_data["className"];
    if(val.type()==typeid(const char *)){
        model_cc_tmp_stream<<*any_cast<const char *>(&val);
    }else if(val.type()==typeid(std::string)||val.type()==typeid(const std::string)){
        model_cc_tmp_stream<<*any_cast<const std::string>(&val);
    }
}
	model_cc_tmp_stream << "::get";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << "(const DbClientPtr &clientPtr, \n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<relationshipClassInde;
	model_cc_tmp_stream << " const std::function<void(std::vector<std::pair<";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << ",";
model_cc_tmp_stream<<pivotTableClassName;
	model_cc_tmp_stream << ">>)> &rcb,\n";
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<indentStr;
	model_cc_tmp_stream << "     ";
model_cc_tmp_stream<<relationshipClassInde;
	model_cc_tmp_stream << " const ExceptionCallback &ecb) const\n";
            }
	model_cc_tmp_stream << "{\n";
	model_cc_tmp_stream << "    const static std::string sql = \"select * from ";
model_cc_tmp_stream<<name;
	model_cc_tmp_stream << ",";
model_cc_tmp_stream<<pivotTableName;
	model_cc_tmp_stream << " where ";
model_cc_tmp_stream<<pivotTableName;
	model_cc_tmp_stream << ".";
model_cc_tmp_stream<<pivotOriginalKey;
	model_cc_tmp_stream << " = ";
            if(rdbms=="postgresql")
            {
                model_cc_tmp_stream<<"$1";
            }
            else
            {
                model_cc_tmp_stream<<"?";
            }
	model_cc_tmp_stream << " and ";
model_cc_tmp_stream<<pivotTableName;
	model_cc_tmp_stream << ".";
model_cc_tmp_stream<<pivotTargetKey;
	model_cc_tmp_stream << " = ";
model_cc_tmp_stream<<name;
	model_cc_tmp_stream << ".";
model_cc_tmp_stream<<relationship.targetKey();
	model_cc_tmp_stream << "\";\n";
	model_cc_tmp_stream << "    *clientPtr << sql\n";
	model_cc_tmp_stream << "               << *";
model_cc_tmp_stream<<nameTransform(relationship.originalKey(), false);
	model_cc_tmp_stream << "_ \n";
	model_cc_tmp_stream << "               >> [rcb = std::move(rcb)](const Result &r){\n";
	model_cc_tmp_stream << "                   std::vector<std::pair<";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << ",";
model_cc_tmp_stream<<pivotTableClassName;
	model_cc_tmp_stream << ">> ret;\n";
	model_cc_tmp_stream << "                   ret.reserve(ret.size());\n";
	model_cc_tmp_stream << "                   for (auto const &row : r)\n";
	model_cc_tmp_stream << "                   {\n";
	model_cc_tmp_stream << "                       ret.emplace_back(std::pair<";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << ",";
model_cc_tmp_stream<<pivotTableClassName;
	model_cc_tmp_stream << ">(\n";
	model_cc_tmp_stream << "                           ";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << "(row),";
model_cc_tmp_stream<<pivotTableClassName;
	model_cc_tmp_stream << "(row,";
model_cc_tmp_stream<<relationshipClassName;
	model_cc_tmp_stream << "::getColumnNumber())));\n";
	model_cc_tmp_stream << "                   }\n";
	model_cc_tmp_stream << "                   rcb(ret);\n";
	model_cc_tmp_stream << "               }\n";
	model_cc_tmp_stream << "               >> ecb;\n";
	model_cc_tmp_stream << "}\n";
        }
    }
if(layoutName.empty())
{
std::string ret{std::move(model_cc_tmp_stream.str())};
return ret;
}else
{
auto templ = DrTemplateBase::newTemplate(layoutName);
if(!templ) return "";
HttpViewData data = model_cc_view_data;
auto str = std::move(model_cc_tmp_stream.str());
if(!str.empty() && str[str.length()-1] == '\n') str.resize(str.length()-1);
data[""] = std::move(str);
return templ->genText(data);
}
}
